<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Snake Fullscreen</title>
    <style>
        /* CSS: Fullscreen Immersion */
        body {
            background-color: #879c85; /* Colore schermo Nokia */
            margin: 0;
            overflow: hidden; /* Blocca lo scroll della pagina */
            touch-action: none; /* Disabilita gesture browser */
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #000;
            font-weight: bold;
            font-size: 18px;
            background: rgba(199, 240, 216, 0.8); /* Backlight semi-trasparente */
            padding: 5px 10px;
            border: 2px solid #333;
            border-radius: 4px;
            pointer-events: none; /* Lascia passare i touch al canvas */
        }
        /* Istruzione iniziale che sparisce */
        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            text-align: center;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="ui-overlay">
    SCORE: <span id="score">0</span> | BEST: <span id="best">0</span>
</div>
<div id="hint">SWIPE TO START</div>

<canvas id="gc"></canvas>

<script>
    const canvas = document.getElementById("gc");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const hintEl = document.getElementById("hint");

    // Configurazione Dinamica
    let gridSize = 20; // Grandezza quadratino
    let tileCountX, tileCountY;
    
    // Stato Gioco
    let px, py;
    let xv = 0, yv = 0;
    let trail = [];
    let tail = 5;
    let score = 0;
    let ax, ay; // Apple position
    let highScore = localStorage.getItem('snake_fs_highscore') || 0;
    let gameRunning = false;
    
    // Swipe Logic Variables
    let touchStartX = 0;
    let touchStartY = 0;

    bestEl.innerText = highScore;

    // Init Engine
    window.onload = () => {
        resize();
        window.addEventListener('resize', resize);
        document.addEventListener('keydown', handleKey); // Fallback PC
        
        // Touch Listeners
        document.addEventListener('touchstart', handleTouchStart, {passive: false});
        document.addEventListener('touchmove', handleTouchMove, {passive: false}); // Blocca scroll
        document.addEventListener('touchend', handleTouchEnd, {passive: false});
        
        setInterval(game, 1000/12); // 12 FPS
    };

    function resize() {
        // Adatta il canvas allo schermo reale
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Calcola quante celle stanno nello schermo
        tileCountX = Math.floor(canvas.width / gridSize);
        tileCountY = Math.floor(canvas.height / gridSize);
        
        // Reset posizioni se fuori schermo
        if(!gameRunning) reset();
    }

    function game() {
        if(!gameRunning) return;

        px += xv;
        py += yv;

        // Logica muri passanti (Wrap) su griglia dinamica
        if(px < 0) px = tileCountX-1;
        if(px > tileCountX-1) px = 0;
        if(py < 0) py = tileCountY-1;
        if(py > tileCountY-1) py = 0;

        // Background pulito
        ctx.fillStyle = "#879c85"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Disegna Serpente
        ctx.fillStyle = "#000";
        for(let i=0; i<trail.length; i++) {
            ctx.fillRect(trail[i].x * gridSize, trail[i].y * gridSize, gridSize-2, gridSize-2);
            
            // Collisione coda
            if(trail[i].x === px && trail[i].y === py) {
                if(tail > 5) gameOver();
            }
        }

        trail.push({x: px, y: py});
        while(trail.length > tail) {
            trail.shift();
        }

        // Collisione Mela
        if(ax === px && ay === py) {
            tail++;
            score++;
            scoreEl.innerText = score;
            spawnApple();
        }

        // Disegna Mela
        ctx.fillStyle = "#000"; 
        ctx.fillRect(ax*gridSize, ay*gridSize, gridSize-2, gridSize-2);
    }

    function spawnApple() {
        ax = Math.floor(Math.random() * tileCountX);
        ay = Math.floor(Math.random() * tileCountY);
    }

    function gameOver() {
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('snake_fs_highscore', highScore);
            bestEl.innerText = highScore;
        }
        reset();
    }

    function reset() {
        tail = 5;
        score = 0;
        scoreEl.innerText = 0;
        trail = [];
        // Start center
        px = Math.floor(tileCountX / 2);
        py = Math.floor(tileCountY / 2);
        xv = 0; yv = 0;
        gameRunning = false;
        hintEl.style.display = "block";
        spawnApple();
        
        // Disegna frame statico di reset
        ctx.fillStyle = "#879c85"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000"; 
        ctx.fillRect(ax*gridSize, ay*gridSize, gridSize-2, gridSize-2);
        ctx.fillRect(px*gridSize, py*gridSize, gridSize-2, gridSize-2);
    }

    // --- INPUT LOGIC (SWIPE) ---

    function handleTouchStart(evt) {
        touchStartX = evt.changedTouches[0].screenX;
        touchStartY = evt.changedTouches[0].screenY;
    }

    function handleTouchMove(evt) {
        // Impedisce il refresh della pagina o lo scroll mentre giochi
        evt.preventDefault();
    }

    function handleTouchEnd(evt) {
        if(!gameRunning) {
            gameRunning = true;
            hintEl.style.display = "none";
        }

        let touchEndX = evt.changedTouches[0].screenX;
        let touchEndY = evt.changedTouches[0].screenY;
        
        handleGesture(touchStartX, touchStartY, touchEndX, touchEndY);
    }

    function handleGesture(sx, sy, ex, ey) {
        let xDiff = ex - sx;
        let yDiff = ey - sy;

        // Rileva swipe solo se il movimento è significativo (>10px)
        if (Math.abs(xDiff) > Math.abs(yDiff)) {
            // Movimento Orizzontale
            if (Math.abs(xDiff) > 10) {
                if (xDiff > 0) changeDir(1, 0); // Destra
                else changeDir(-1, 0); // Sinistra
            }
        } else {
            // Movimento Verticale
            if (Math.abs(yDiff) > 10) {
                if (yDiff > 0) changeDir(0, 1); // Giù
                else changeDir(0, -1); // Su
            }
        }
    }

    function changeDir(x, y) {
        // Anti-suicidio (non puoi tornare indietro di colpo)
        if (x === -xv && x !== 0) return;
        if (y === -yv && y !== 0) return;
        xv = x;
        yv = y;
    }

    function handleKey(evt) {
        if(!gameRunning) { gameRunning = true; hintEl.style.display = "none"; }
        switch(evt.keyCode) {
            case 37: changeDir(-1, 0); break;
            case 38: changeDir(0, -1); break;
            case 39: changeDir(1, 0); break;
            case 40: changeDir(0, 1); break;
        }
    }
</script>
</body>
</html>
